# 17. 제어자 modifier
제어자: 클래스, 변수 또는 메서드의 선언부와 함께 사용되어 부가적인 의미를 부여한다.
- 종류: 접근 제어자, 그외의 제어자
    - 접근 제어자: public, protectd, (default), private
    - 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp
        - static, final, abstract 말고는 자주 사용되지 않는다.
- 제어자는 클래스나 멤버변수와 메서드에 주로 사용되며, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.
- 단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.
    - 즉, 하나의 대상에 public과 private을 함께 사용할 수 없다.
- 제어자들 간 순서는 상관없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.

# 18. static - 클래스의, 공통적인
인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스 변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다.
- 그 이유는 하나의 변수를 모든 인스턴스가 공유하기 때문이다.

> static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

## static 제어자의 대상과 의미
- 대상: 멤버변수
    - 의미
        - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
        - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
        - 클래스가 메모리에 로드될 때 생성된다.
- 대상: 메서드
    - 의미
        - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
        - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.

```java
class StaticTest {
    static int width = 200; // 클래스 변수 (static변수)
    static int height = 120; // 클래스 변수 (static변수)
    
    static { // 클래스 초기화 블럭
        // static변수의 복잡한 초기화 수행
    }
    
    static int max(int a, int b) { // 클래스 메서드 (static메서드)
        return a > b ? a : b;
    }
}
```

# 19. final - 마지막의, 변경될 수 없는
거의 모든 대상에 사용될 수 있다.
- **변수**에 사용되면 값을 변경할 수 없는 **상수**가 되며,
- **메서드**에 사용되면 **오버라이딩을 할 수 없게 되고**,
- **클래스**에 사용되면 자신을 확장하는 **자손클래스를 정의하지 못하게 된다**.

> final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

## final 제어자의 대상과 의미
- 대상: 클래스
  - 의미
    - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
    - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
- 대상: 메서드
  - 의미
    - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
- 대상: 멤버변수, 지역변수
  - 의미
    - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

```java
final class FinalTest { // 조상이 될 수 없는 클래스 
    final int MAX_SIZE = 10; // 값을 변경할 수 없는 지역변수(상수)
    
    final void getMaxSize() { // 오버라이딩을 할 수 없는 메서드(변경불가)
        final int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수) 
        return MAX_SIZE;
    }
}
```

# 20. abstract - 추상의, 미완성의
메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.

> abstract이 사용될 수 있는 곳 - 클래스, 메서드

## abstract 제어자의 대상과 의미
- 대상: 클래스
  - 의미
    - 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
- 메서드
  - 의미
    - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

```java
abstract class AbstractTest { // 추상 클래스, 추상 메서드를 포함한 클래스
    abstract void move(); // 추상메서드, 구현부가 없는 메서드
}

AbstractTest a = new AbstractTest() {}; // 에러, 추상 클래스의 인스턴스 생성불가
```
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 **'미완성 설계도'**이므로 인스턴스를 생성할 수 없다.

# 24. 접근 제어자 access modifier
접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
- 접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지 않는다. 클래스나 멤버 변수, 메서드, 생성자에 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.

> 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
> - private : 같은 클래스 내에서만 접근이 가능하다.
> - (default) : 같은 패키지 내에서만 접근이 가능하다.
> - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
> - public: 접근 제한이 전혀 없다.
>
>> 접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 왼쪽부터 나열하면 다음과 같다.
>> `public`(`접근제한없음`)  >  `protected`(`같은 패키지+자손`)  >  `(default)`(`같은 패키지`) > `private`(`같은 클래스`)

# 22. 캡슐화와 접근 제어자
**접근 제어자를 사용하는 잉는 클래스의 내부에 선언된 데이터를 보호하기 위해서**다. 
- 데이터가 유효한 값을 유지하도록, 또는 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.
  - data hiding, encapsulation에 해당하는 내용

또다른 이유는 **클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서**다.
- 외부에서 접근할 필요가 없는 멤버들은 private으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다.
  - encapsualtion에 해당된다.

  

